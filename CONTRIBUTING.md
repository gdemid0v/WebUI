# Документация к shell-скриптам веб-интерфейса устройства

Данная документация содержит подробные комментарии к четырем shell-скриптам (`apply_network.sh`, `data_api.sh`, `di_do_api.sh`, `relay_api.sh`), которые используются в веб-интерфейсе для управления устройством. Комментарии объясняют каждую строку кода, что помогает понять логику работы скриптов и упрощает их модификацию или отладку.

---

## 1. `apply_network.sh`

**Назначение**:  
Скрипт обрабатывает POST-запрос с JSON-данными (IP-адрес и маска подсети), создает файл конфигурации сетевого интерфейса и возвращает результат в формате JSON.

```bash
#!/bin/sh
# Указывает, что скрипт использует интерпретатор sh (обычно это Bourne Shell или его совместимая версия, например bash).

echo "Content-Type: application/json"
# Выводит HTTP-заголовок, указывающий, что ответ будет в формате JSON.

echo ""
# Выводит пустую строку, которая отделяет заголовки от тела ответа (стандарт для HTTP).

read -r data
# Читает данные, переданные в POST-запросе, и сохраняет их в переменную data. Опция -r предотвращает интерпретацию обратных слешей.

ip=$(echo "$data" | sed -n 's/.*"ip":"\([^"]*\)".*/\1/p')
# Извлекает значение поля "ip" из JSON-строки, используя sed: ищет "ip":"значение" и захватывает значение в кавычках.

mask=$(echo "$data" | sed -n 's/.*"mask":"\([^"]*\)".*/\1/p')
# Извлекает значение поля "mask" из JSON-строки аналогичным образом, сохраняя его в переменную mask.

if [ -z "$ip" ] || [ -z "$mask" ]; then
# Проверяет, пусты ли переменные ip или mask. -z возвращает true, если строка пустая.

    echo '{"status": "error", "message": "Invalid IP or mask"}' >&2
    # Если ip или mask пусты, выводит JSON с ошибкой в stderr (>&2 перенаправляет в stderr).

    exit 1
    # Завершает выполнение скрипта с кодом ошибки 1 (указывает на неудачу).

fi
# Конец условного оператора if.

config_dir="/tmp"
# Задает переменную config_dir со значением "/tmp" — директория для временных файлов.

new_file="interfaces_$(date +%s).conf"
# Создает имя файла, добавляя временную метку (время в секундах с эпохи) к строке "interfaces_", например, "interfaces_1698765432.conf".

full_path="${config_dir}/${new_file}"
# Формирует полный путь к файлу, соединяя config_dir и new_file, например, "/tmp/interfaces_1698765432.conf".

cat > "$full_path" <<EOF
# Использует heredoc (<<EOF) для создания файла по пути full_path с содержимым, указанным ниже.

# Configure Loopback
# Комментарий в файле: указывает, что далее идет настройка loopback-интерфейса.

auto lo
# Указывает, что интерфейс lo будет автоматически запускаться при загрузке системы.

iface lo inet loopback
# Определяет интерфейс lo как loopback с использованием протокола IPv4 (inet).

#
# Пустая строка для разделения настроек интерфейсов.

auto eth0
# Указывает, что интерфейс eth0 будет автоматически запускаться при загрузке системы.

iface eth0 inet static
# Определяет интерфейс eth0 как статический IPv4-интерфейс (не DHCP).

 hwaddress ether 00:00:00:00:00:AA
 # Задает фиксированный MAC-адрес для eth0 (в данном случае 00:00:00:00:00:AA).

 address $ip
 # Устанавливает IP-адрес интерфейса eth0, используя значение переменной ip.

 netmask $mask
 # Устанавливает маску подсети для eth0, используя значение переменной mask.

#gateway 192.168.1.1
# Закомментированная строка: шлюз по умолчанию (не используется в текущей версии скрипта).

EOF
# Конец блока heredoc, завершает запись в файл.

if [ -f "$full_path" ]; then
# Проверяет, существует ли файл по пути full_path (-f возвращает true, если файл существует и является обычным файлом).

    echo '{"status": "success", "filename": "'$new_file'"}'
    # Выводит JSON с успешным статусом и именем созданного файла (без полного пути).

else
# Начало блока else, выполняемого, если файл не был создан.

    echo '{"status": "error", "message": "File creation failed"}' >&2
    # Выводит JSON с ошибкой в stderr, если файл не удалось создать.

    exit 1
    # Завершает выполнение скрипта с кодом ошибки 1.

fi
# Конец условного оператора if.
```

---

## 2. `data_api.sh`

**Назначение**:  
Скрипт возвращает общую информацию об устройстве (производитель, модель, IP-адрес, маска подсети, время работы и текущее время) в формате JSON.

```bash
#!/bin/sh
# Указывает, что скрипт использует интерпретатор sh.

echo "Content-Type: application/json; charset=utf-8"
# Выводит HTTP-заголовок, указывающий, что ответ будет в формате JSON с кодировкой UTF-8.

echo ""
# Выводит пустую строку для отделения заголовков от тела ответа.

MANUFACTURER="РЭА-Т"
# Задает переменную MANUFACTURER со значением "РЭА-Т" (название производителя).

MODEL="КРОНОС SI-SDB2-MB-2U"
# Задает переменную MODEL со значением "КРОНОС SI-SDB2-MB-2U" (модель устройства).

INTERFACE="eth0"
# Задает переменную INTERFACE со значением "eth0" (имя сетевого интерфейса).

ip_output=$(ip -4 addr show "$INTERFACE")
# Выполняет команду ip для получения информации об IPv4-адресах интерфейса eth0 и сохраняет результат в ip_output.

IP_Address=$(echo "$ip_output" | grep -o 'inet [0-9.]*' | awk '{print $2}')
# Извлекает IP-адрес из вывода команды ip: ищет строку с "inet", затем берет второе поле (сам адрес).

Netmask=$(echo "$ip_output" | grep -o 'inet [0-9./]*' | cut -d'/' -f2)
# Извлекает маску подсети в формате CIDR (например, 24) из вывода команды ip, обрезая после "/".

Time=$(date "+%H:%M:%S %d.%m.%Y")
# Получает текущее время в формате "ЧЧ:ММ:СС ДД.ММ.ГГГГ" и сохраняет в переменную Time.

UPtime=$(awk '{printf $1}' /proc/uptime)
# Читает время работы системы в секундах из файла /proc/uptime и сохраняет только первое поле (время в секундах).

cat <<EOF
# Использует heredoc (<<EOF) для вывода JSON-объекта.

{
# Открывает JSON-объект.

  "Manufacturer": "$MANUFACTURER",
  # Добавляет поле "Manufacturer" с значением переменной MANUFACTURER.

  "Model": "$MODEL",
  # Добавляет поле "Model" с значением переменной MODEL.

  "IP-Address": "$IP_Address",
  # Добавляет поле "IP-Address" с значением переменной IP_Address.

  "Netmask": "$Netmask",
  # Добавляет поле "Netmask" с значением переменной Netmask.

  "UPtime": "$UPtime",
  # Добавляет поле "UPtime" с значением переменной UPtime.

  "Time": "$Time"
  # Добавляет поле "Time" с значением переменной Time (без запятой, так как это последний элемент).

}
# Закрывает JSON-объект.

EOF
# Конец блока heredoc, завершает вывод.
```

---

## 3. `di_do_api.sh`

**Назначение**:  
Скрипт читает конфигурационный файл `/etc/cons/cons.conf` и возвращает данные о цифровых входах/выходах (DI/DO) в формате JSON.

```bash
#!/bin/sh
# Указывает, что скрипт использует интерпретатор sh.

echo "Content-Type: application/json; charset=utf-8"
# Выводит HTTP-заголовок для JSON с кодировкой UTF-8.

echo ""
# Выводит пустую строку для отделения заголовков от тела.

CONFIG_FILE="/etc/cons/cons.conf"
# Задает переменную CONFIG_FILE с путем к конфигурационному файлу "/etc/cons/cons.conf".

JSON="{"
# Инициализирует переменную JSON открывающей фигурной скобкой для JSON-объекта.

FIRST_ENTRY=1
# Устанавливает флаг FIRST_ENTRY в 1 (используется для корректного добавления запятых между элементами JSON).

while IFS= read -r line; do
# Запускает цикл, читающий файл CONFIG_FILE построчно. IFS= предотвращает обрезку пробелов, -r — интерпретацию слешей.

    case "$line" in
    # Начало оператора case для обработки строк из файла.

        DIGITAL[0-9]*\ =*|DIGDIR[0-9]*\ =*)
        # Сопоставляет строки, начинающиеся с "DIGITAL" или "DIGDIR", за которыми следуют цифры и " =".

            key=${line%% *}
            # Извлекает ключ (например, "DIGITAL1") — все до первого пробела.

            path=${line#*= }
            # Извлекает путь (значение после "= ") из строки.

            value=$( [ -r "$path" ] && tr -d '\n\r' < "$path" 2>/dev/null || echo "error" )
            # Проверяет, читаем ли файл по пути path (-r). Если да, удаляет \n и \r и читает значение; иначе возвращает "error".

            [ "$FIRST_ENTRY" -eq 0 ] && JSON="$JSON," || FIRST_ENTRY=0
            # Если FIRST_ENTRY равно 0, добавляет запятую перед новым элементом; затем сбрасывает FIRST_ENTRY в 0.

            JSON="$JSON \"$key\": { \"path\": \"$path\", \"value\": \"$value\" }"
            # Добавляет в JSON запись с ключом, путем и значением в формате "key": {"path": "path", "value": "value"}.

            ;;
        # Конец ветки case.

    esac
    # Конец оператора case.

done < "$CONFIG_FILE"
# Указывает, что цикл читает из файла, заданного в CONFIG_FILE.

JSON="$JSON }"
# Закрывает JSON-объект, добавляя закрывающую фигурную скобку.

echo "$JSON"
# Выводит сформированный JSON-объект.
```

---

## 4. `relay_api.sh`

**Назначение**:  
Скрипт читает конфигурационный файл `/etc/cons/cons.conf` и возвращает данные о состоянии реле в формате JSON.

```bash
#!/bin/sh
# Указывает, что скрипт использует интерпретатор sh.

echo "Content-Type: application/json; charset=utf-8"
# Выводит HTTP-заголовок для JSON с кодировкой UTF-8.

echo ""
# Выводит пустую строку для отделения заголовков от тела.

CONFIG_FILE="/etc/cons/cons.conf"
# Задает переменную CONFIG_FILE с путем к конфигурационному файлу "/etc/cons/cons.conf".

FIRST_ENTRY=1
# Устанавливает флаг FIRST_ENTRY в 1 для управления запятыми в JSON.

printf '{'
# Выводит открывающую фигурную скобку JSON-объекта (без переноса строки).

while IFS= read -r line; do
# Запускает цикл, читающий файл CONFIG_FILE построчно. IFS= сохраняет пробелы, -r — слеши.

    case "$line" in
    # Начало оператора case для обработки строк.

        RELAY[0-9]*\ =*)
        # Сопоставляет строки, начинающиеся с "RELAY", за которыми следуют цифры и " =".

            key=${line%% *}
            # Извлекает ключ (например, "RELAY1") — все до первого пробела.

            path=${line#*= }
            # Извлекает путь (значение после "= ") из строки.

            if [ -f "$path" ]; then
            # Проверяет, существует ли файл по пути path и является ли он обычным файлом (-f).

                value=$(tr -d '\r\n' < "$path")
                # Читает значение из файла, удаляя символы возврата каретки и перевода строки.

            else
            # Начало блока else, если файл не существует.

                value="error"
                # Устанавливает значение "error", если файл не найден.

            fi
            # Конец условного оператора if.

            [ "$FIRST_ENTRY" -eq 0 ] && printf ',' || FIRST_ENTRY=0
            # Если FIRST_ENTRY равно 0, выводит запятую; затем сбрасывает FIRST_ENTRY в 0.

            esc_path=$(printf '%s' "$path" | sed 's/"/\\"/g')
            # Экранирует кавычки в пути, заменяя " на \" для корректного JSON.

            esc_value=$(printf '%s' "$value" | sed 's/"/\\"/g')
            # Экранирует кавычки в значении аналогичным образом.

            printf ' "%s": { "path": "%s", "value": "%s" }' "$key" "$esc_path" "$esc_value"
            # Выводит запись в формате "key": {"path": "path", "value": "value"} с экранированными значениями.

            ;;
        # Конец ветки case.

    esac
    # Конец оператора case.

done < "$CONFIG_FILE"
# Указывает, что цикл читает из файла CONFIG_FILE.

printf ' }\n'
# Выводит закрывающую фигурную скобку JSON-объекта и перевод строки.
```

---

## Заключение
Комментарии к коду призваны помочь разработчикам и администраторам понять логику работы каждого скрипта. Они могут быть использованы для отладки, модификации или расширения функциональности веб-интерфейса устройства.
